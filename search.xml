<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>继承</title>
      <link href="/posts/28439.html"/>
      <url>/posts/28439.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的类</title>
      <link href="/posts/826.html"/>
      <url>/posts/826.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>众所周知，Python是一门面向对象的编程语言，在所有面向对象的编程语言中，类起着重要的作用，今天二刷完了Python基础，总结一下<strong>类</strong>的相关知识。</p><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><h3 id="如何创建一个类"><a href="#如何创建一个类" class="headerlink" title="如何创建一个类"></a>如何创建一个类</h3><h3 id="如何理解类的实例化"><a href="#如何理解类的实例化" class="headerlink" title="如何理解类的实例化"></a>如何理解类的实例化</h3><h3 id="如何理解类的属性"><a href="#如何理解类的属性" class="headerlink" title="如何理解类的属性"></a>如何理解类的属性</h3><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> Pyhton </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串行通信接口</title>
      <link href="/posts/63918.html"/>
      <url>/posts/63918.html</url>
      
        <content type="html"><![CDATA[<h1 id="串行通信接口"><a href="#串行通信接口" class="headerlink" title="串行通信接口"></a>串行通信接口</h1><p>与串行通信有关的几个寄存器，接受/发送缓冲器<code>SBUF</code>、串行口控制寄存器<code>SCON</code>、电源控制寄存器<code>PCON</code>、中断允许控制寄存器<code>IE</code>、中断优先级控制寄存器<code>IP</code>。</p><h1 id="串行通信接口的结构"><a href="#串行通信接口的结构" class="headerlink" title="串行通信接口的结构"></a>串行通信接口的结构</h1><h1 id="SCON串行口控制寄存器"><a href="#SCON串行口控制寄存器" class="headerlink" title="SCON串行口控制寄存器"></a><code>SCON</code>串行口控制寄存器</h1><h2 id="SCON各位定义"><a href="#SCON各位定义" class="headerlink" title="SCON各位定义"></a><code>SCON</code>各位定义</h2><h1 id="串行通信的4种工作方式"><a href="#串行通信的4种工作方式" class="headerlink" title="串行通信的4种工作方式"></a>串行通信的4种工作方式</h1><h2 id="串行工作方式0"><a href="#串行工作方式0" class="headerlink" title="串行工作方式0"></a>串行工作方式0</h2><h2 id="串行工作方式1"><a href="#串行工作方式1" class="headerlink" title="串行工作方式1"></a>串行工作方式1</h2><h2 id="串行工作方式2和3"><a href="#串行工作方式2和3" class="headerlink" title="串行工作方式2和3"></a>串行工作方式2和3</h2><h1 id="串行通信接口应用实例"><a href="#串行通信接口应用实例" class="headerlink" title="串行通信接口应用实例"></a>串行通信接口应用实例</h1><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部函数intrins.h</title>
      <link href="/posts/38755.html"/>
      <url>/posts/38755.html</url>
      
        <content type="html"><![CDATA[<h1 id="intrins-h中的-crol-和-cror-的使用"><a href="#intrins-h中的-crol-和-cror-的使用" class="headerlink" title="intrins.h中的_crol_和_cror_的使用"></a>intrins.h中的_crol_和_cror_的使用</h1><p>之前做单片机控制LED实现流水闪烁实验时，接触到内部函数intrins.h的使用。今天做一下记录</p><h1 id="函数crol"><a href="#函数crol" class="headerlink" title="函数crol"></a>函数<em>crol</em></h1><p><code>_crol_</code>在intrins.h的声明是这样的</p><p><code>unsigned char _crol_(unsigned char val, unsigned n); // 其功能是使val的二进制形式循环左移n位</code></p><p>例如：语句<code>_crol_(8,1)</code>,8的二进制是00001000B，将其循环左移1位返回值是00010000B。</p><h1 id="函数cror"><a href="#函数cror" class="headerlink" title="函数cror"></a>函数<em>cror</em></h1><p>相似的，<code>_cror_</code>在intrins.h的声明</p><p><code>unsigned char _cror_(unsigned char val, unsigned n); // 其功能是使val的二进制形式循环右移n位</code></p><p>同样的，语句<code>_cror_(8,1)</code>,返回值是00000100B</p><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p><strong>要求：使用_crol_和_cror_函数通过单片机控制8个LED灯流水闪烁。</strong></p><p><strong>Proteus仿真图</strong></p><p>连线使用了标号连接</p><p><img src="/posts/38755/0.png" alt></p><p><strong>源代码</strong></p><pre class="line-numbers language-C"><code class="language-C">#include<reg51.h>#include<intrins.h> // 头部文件// #include<reg51.h>// #include<intrins.h>void delay100ms(void)   //误差 0us 用单片机小精灵生成的{    unsigned char a,b,c;    for(c=19;c>0;c--)        for(b=20;b>0;b--)            for(a=130;a>0;a--);}void main(){    unsigned char Data,i;    unsigned int Data1;    Data=0xfe;      // 二进制11111110B     Data1=0x7f;      // 二进制01111111B     while(1)    {        for(i=0;i<8;i++)              // 循环8次，可执行_crol_函数8次，将Data各位循环左移8次，即8个LED逐个点亮。        {            P2=Data;                // 将Data传递给P2口            Data=_crol_(Data,1);    // 11111110B各位左移1位            delay100ms();        }        for(i=0;i<8;i++)            // 与上面道理相似，这是控制Data1各位右移        {            P2=Data1;            Data1=_cror_(Data1,1);            delay100ms();            P0=Data;        }    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果可使用Proteus和Keil进行仿真。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时/计数器初值的计算</title>
      <link href="/posts/31297.html"/>
      <url>/posts/31297.html</url>
      
        <content type="html"><![CDATA[<h3 id="51单片机的定时-计数器初值的计算方法"><a href="#51单片机的定时-计数器初值的计算方法" class="headerlink" title="51单片机的定时/计数器初值的计算方法"></a><strong>51单片机的定时/计数器初值的计算方法</strong></h3><p>51单片机的定时/计数的范围根据工作方式的变化而变化，在方式0下工作时，<code>TH0</code>的8位和<code>TL0</code>的低5位构成13位的定时/计数器，范围是<code>2^13</code>;方式1为<code>2^16</code>;方式2为<code>2^8</code>;方式3是两个独立的定时计数器都是<code>2^8</code>。</p><h3 id="计数功能"><a href="#计数功能" class="headerlink" title="计数功能"></a>计数功能</h3><p>初值 = 计数范围 - 目标计数值<br><code>X = M - N</code><br>其中计数范围(M)会随工作方式的变化而变化，目标计数值(N)就是你想让计数器计数到X时溢出计数加1的值。</p><p><strong>例如：</strong>一道工序需要外部脉冲信号计数<code>100</code>次，即<code>X = M - 100</code></p><h3 id="定时功能"><a href="#定时功能" class="headerlink" title="定时功能"></a>定时功能</h3><p>以方式1为例，如果时钟周期是<code>12MHz</code>，那么机器周期就是<code>1μs</code>，方式1的计数范围就是<code>0-65536μs</code>，现在我们要定时<code>20ms</code>，也就是<code>20000μs</code>，那么初值就应该装入<code>65536-20000</code>，程序为<code>TH0 = (65536-20000)/256</code>, <code>TL0 = (65536-20000)%256</code>。</p><p>如果我们想定时1s怎么办呢？<br>先定时<code>50ms(50000μs)</code>，然后循环<code>20</code>次，<code>1s = 1000ms</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时/计数器</title>
      <link href="/posts/14549.html"/>
      <url>/posts/14549.html</url>
      
        <content type="html"><![CDATA[<h2 id="定时-计数器"><a href="#定时-计数器" class="headerlink" title="定时/计数器"></a>定时/计数器</h2><p><code>MSC51</code>单片机中有两个16位可编程的定时/计数器，定时/计数器0(T0)和定时/计数器(T1)，有4种工作方式，都受<code>TMOD</code>和<code>TCON</code>两个特殊功能寄存器控制。其工作方式都由软件控制。</p><h3 id="定时-计数器的结构"><a href="#定时-计数器的结构" class="headerlink" title="定时/计数器的结构"></a>定时/计数器的结构</h3><h3 id="加1计数器"><a href="#加1计数器" class="headerlink" title="加1计数器"></a>加1计数器</h3><p>T0和T1的核心都是16位的加1计数器，TH0和TL0构成定时/计数器T0加1<br>计数器的高8位和低8位，相应的T1为TH1和TL1。</p><p>其初值由程序设定，可给TH0、TL0赋初值，在定时/计数器的工作方式部分详解。</p><h3 id="定时-计数器控制寄存器-TCON"><a href="#定时-计数器控制寄存器-TCON" class="headerlink" title="定时/计数器控制寄存器(TCON)"></a>定时/计数器控制寄存器(TCON)</h3><p><strong>功能</strong></p><ul><li>参与定时/计数器控制</li><li>参与中断请求控制</li><li>每位都可位操作</li></ul><p><strong>TCON各位定义</strong></p><p><img src="/posts/14549/2.png" alt></p><p><strong>TCON各位功能</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>TF0和TF1</td><td>分别是T0和T1的计数溢出中断。TF0=1或TF1=0是计数溢出；TF0=0或TF1=0是计数未满。</td></tr><tr><td>TR0和TR1</td><td>分别是T0和T1的启/停控制位。TR0=1或TR1=1，启动计数；TR0=0或TR1=0，停止计数。</td></tr><tr><td>IE0和IE1，IT0和IT1</td><td>管理外部中断</td></tr></tbody></table><h3 id="工作方式寄存器-TMOD"><a href="#工作方式寄存器-TMOD" class="headerlink" title="工作方式寄存器(TMOD)"></a>工作方式寄存器(TMOD)</h3><p><strong>功能</strong></p><ul><li>控制定时/计数器的工作方式</li><li>只能字节操作</li></ul><p><strong>TMOD各位定义</strong></p><p><img src="/posts/14549/1.png" alt></p><p><strong>TMOD各位功能</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>GATE</td><td>门控信号。当GATE=0时，TRx=1即可启动定时/计数器工作；当GATE=1是，TRx=1和INTx=1才可以启动定时/计数器工作(x可取0或1)</td></tr><tr><td>C/T</td><td>定时/计数器功能选择位。当C/T=0，是定时功能；C/T=1,是计数功能</td></tr><tr><td>M1和M0</td><td>工作方式选择位。</td></tr></tbody></table><p>定时/计数器有四种工作方式：</p><ul><li>M1M0 = 00 工作方式0 (13位方式)</li><li>M1M0 = 01 工作方式1 (16位方式)</li><li>M1M0 = 10 工作方式2 (8位自动再装入方式)</li><li>M1M0 = 11 工作方式3 (T0为两个8位方式)</li></ul><p><strong>定时/计数器工作方式的选择</strong></p><ul><li><p>当C/T = 0时，选择定时器功能；当C/T = 1时，选择计数器功能。</p></li><li><blockquote><p>定时器功能(C/T=0)：对单片机内部机器周期产生的脉冲进行计数，加1计数器对每个机器周期自动加1。如果单片机的晶振频率为12MHz，则计数频率为1MHz，即加1计数器每加1，可实现1μs的计数。</p></blockquote></li><li><blockquote><p>计数器功能(C/T=1)：对外部事件产生的脉冲进行计数。MCS51单片机的P3.4和P3.5两个引脚分别是T0和T1计数器的计数脉冲信号输入端，当该引脚输入脉冲发生负跳变(高电平到低电平)时，加1计数器自动加1。</p></blockquote></li></ul><h3 id="定时-计数器的工作方式"><a href="#定时-计数器的工作方式" class="headerlink" title="定时/计数器的工作方式"></a>定时/计数器的工作方式</h3><p>定时计数器有四种工作方式，由TMOD中的M1和M0两位决定。</p><h4 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h4><p>当M1M0 = 00时，13位定时/计数器(TH的8位和TL的低5位)。以T0为例。</p><p><strong>计数器(C/T=1)状态</strong></p><p>加1计数器对T0引脚上的外部输入脉冲计数。计数的值<code>N = 2^13-x = 8192-x</code>。计数初值x是由TH0和TL0设定的初值。</p><ul><li>计数范围：当x=8191时为最小计数值1，x=0时为最大计数值8192。计数范围为1 ~ 8192(2^13)。</li></ul><p><strong>定时器(C/T=0)状态</strong></p><p>加1计数器对机器周期(<code>Tcy</code>)脉冲计数，定时时间为<code>Td = (8192-x) * Tcy</code>。如果晶振频率fosc = 12MHz，即机器周期1μs，定时范围为(1~8192μs)。</p><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><p>当M1M0 = 01时，16位定时/计数器(TH的8位和TL的8位)。以T0为例。</p><p>其与方式0的工作模式大致相同，只是定时时间和计数范围与方式0不同。TH和TL两个寄存器的8位都有效，所以16位</p><ul><li>计数范围：1~65536(2^16)。</li><li>定时范围：1~65536μs。</li></ul><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><p>T0、T1工作模式完全相同，以T0为例。<br>当M1M0 = 10时，定时/计数器选定方式2进行工作。16位加1计数器被分为两个8位寄存器TL0和TH0，其中TL0为加1计数器，TH0作为TL0的初值预置寄存器，且TH0数值始终为初值常数。</p><p>当TL0计数溢出时，系统将溢出标志位(TF0)置位，申请中断，同时TH0中的初值重新装入TL0。</p><h4 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h4><p>工作方式3适用于单片机需要1个独立的定时/计数器、1个定时器的情况。</p><h2 id="定时-计数器应用实例"><a href="#定时-计数器应用实例" class="headerlink" title="定时/计数器应用实例"></a>定时/计数器应用实例</h2><p><strong>实例</strong>：用定时器T0查询方式控制P2口8位LED闪烁</p><p>要求：</p><ul><li>闪烁周期为100ms，亮50ms，灭50ms</li></ul><p><code>TMOD = 0x01</code> 即0000 0001B，在TMOD寄存器中低四位控制T0的工作方式；GATE = 0 只需要TR0 = 1，T0就可以启动；C/T = 0 为定时器功能；M0M1=01，为工作方式1</p><p><strong>定时计数器初值的计算</strong></p><p><code>Proteus</code>仿真图<br><img src="/posts/14549/0.png" alt></p><p><strong>源代码</strong></p><pre class="line-numbers language-C"><code class="language-C"># include <reg51.h>void T0init(){    TMOD = 0x01;                   // TMOD = 0000 0001B 只能字节操作 工作方式1    TH0 = (65536 - 46083) / 256;   // TH0赋初值    TL0 = (65536 - 46083) % 256;   // TL0赋初值    TR0 = 1;                        // 定时器T0打开    P2 = 0xff;                       // 熄灭8个LED灯}void main(){    T0init();    while(1)    {        while(TF0 == 0)   // 定时器T0溢出标志位，当TF=1是产生中断请求。            ;         TF0 = 0;          // TF0置1后需要手动恢复。         P2 = ~P2;         // P2口取反        TH0 = (65536 - 46083) / 256;   // TH0重新赋值        TL0 = (65536 - 46083) % 256;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给Hexo博客绑定个人域名</title>
      <link href="/posts/34584.html"/>
      <url>/posts/34584.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们搭建好了自己的Hexo博客，可供访问的域名就是<code>username.github.io</code>，顾名思义<code>username</code>就是你的<code>GitHub</code>的用户名。废话不多说了，上才艺。</p><p>绑定域名之前需要自行购买域名，推荐<a href="https://www.aliyun.com" target="_blank" rel="noopener">阿里云</a>、<a href="https://cloud.tencent.com" target="_blank" rel="noopener">腾讯云</a>。当然也有其他许多国内外知名域名提供商可供购买，这里以腾讯云为例。</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><blockquote><ul><li>首先访问腾讯云官网</li></ul></blockquote><p><strong>点击域名特惠</strong></p><p><img src="/posts/34584/1.png" alt></p><p><strong>选择域名格式</strong></p><ul><li>腾讯云提供10+种域名，不同格式的域名收费不同，根据个人喜好和需求甄选格式。</li></ul><p><img src="/posts/34584/2.png" alt></p><p><strong>点击立即购买</strong></p><ul><li>点完购买会弹出登录窗口，根据提示，注册帐号。</li></ul><p><strong>提示</strong>：注册后，找到账号信息，进行账号的实名认证</p><p><img src="/posts/34584/3.png" alt></p><p><strong>查询域名</strong></p><ul><li>输入心仪的域名，查看是否已被注册。如果没有被注册点击一键购买</li></ul><p><img src="/posts/34584/4.png" alt></p><p><strong>支付</strong></p><p><img src="/posts/34584/6.png" alt></p><p><strong>这样就购买了一个专属域名</strong></p><h2 id="实名认证"><a href="#实名认证" class="headerlink" title="实名认证"></a>实名认证</h2><p><strong>点击域名管理</strong></p><blockquote><ul><li>在云产品的下拉选项卡中找到<strong>域名管理</strong>，</li></ul></blockquote><p><img src="/posts/34584/8.png" alt></p><blockquote><ul><li>下面可以看到这里的服务状态是<strong>正常</strong>，因为这个是我自己的，已经实名认证了。如果没有实名认证，这个位置会显示<strong>未实名</strong>。点击未实名，根据步骤完成域名的实名认证。<br><img src="/posts/34584/9.png" alt></li></ul></blockquote><p><strong>这样就完成了域名的实名认证</strong></p><p><strong>可能需要等一段时间</strong></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><blockquote><ul><li>实名认证通过后，找到<strong>域名管理</strong>或者<strong>DNS解析 DNSPod</strong>，进入找到如下界面</li></ul></blockquote><p><img src="/posts/34584/10.png" alt></p><p><strong>点击解析</strong></p><blockquote><ul><li>跳转到如下界面</li></ul></blockquote><p><img src="/posts/34584/11.png" alt></p><p><strong>点击快速添加网站/邮箱解析</strong></p><blockquote><ul><li>跳转的如下界面</li></ul></blockquote><p><img src="/posts/34584/12.png" alt></p><p><strong>点击立即设置</strong></p><p><img src="/posts/34584/13.png" alt></p><p>这里需要输入的<code>IP</code>就是我们<code>Hexo</code>博客所对应的<code>IP</code>，下一步我们获取IP地址</p><h2 id="获取IP"><a href="#获取IP" class="headerlink" title="获取IP"></a>获取<code>IP</code></h2><blockquote><ul><li><code>Win+R</code>输入<code>cmd</code>敲回车，输入指令<code>ping username.github.io</code>敲回车。</li></ul></blockquote><p><img src="/posts/34584/14.png" alt></p><p>这样就获取到IP地址了输入到上一步的空格中，点击确定即可。</p><h2 id="绑定GitHub"><a href="#绑定GitHub" class="headerlink" title="绑定GitHub"></a>绑定<code>GitHub</code></h2><p>访问自己的<code>GitHub</code>帐号的<code>repositories</code>主页，点击<code>Hexo</code>博客所部署的仓库。</p><p><img src="/posts/34584/15.png" alt></p><p><strong>点击<code>Settings</code></strong></p><p><img src="/posts/34584/16.png" alt></p><p><strong>找到<code>Custom domain</code></strong></p><p>在空白框中填写购买的域名</p><p><img src="/posts/34584/17.png" alt></p><h2 id="创建CNAME"><a href="#创建CNAME" class="headerlink" title="创建CNAME"></a>创建<code>CNAME</code></h2><p>我们在博客根目录下的<code>source</code>目录下创建一个名为<code>CNAME</code>的文件，并且把域名填入。我的是<code>H:\Blog\source</code></p><p><strong>提示</strong>：可以像我一样，首先创建一个<code>CNAME.txt</code>，把域名输入<code>txt</code>文件，然后重命名把<code>.txt</code>删除即可。</p><p><img src="/posts/34584/18.png" alt></p><h2 id="访问自己的域名试试看"><a href="#访问自己的域名试试看" class="headerlink" title="访问自己的域名试试看"></a>访问自己的域名试试看</h2><p><img src="/posts/34584/19.png" alt></p><p><strong>大功告成</strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅谈个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCS-51中断、定时/计数器</title>
      <link href="/posts/19124.html"/>
      <url>/posts/19124.html</url>
      
        <content type="html"><![CDATA[<h2 id="MCS-51中断系统"><a href="#MCS-51中断系统" class="headerlink" title="MCS-51中断系统"></a>MCS-51中断系统</h2><blockquote><ul><li>记录对51单片机中断、定时/计数器的重要知识点以及难点理解，并且举例中断在实际编程中的应用，从而加深对单片机中断、定时/计数器的理解，熟练的使用中断。</li></ul></blockquote><h3 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h3><blockquote><ul><li><strong>中断</strong>就是计算机在执行某一程序的过程中，由计算机系统内部或外部的某种原因而<strong>必须终止当前程序的运行</strong>，<strong>先去执行相应的处理程序</strong>，然后再<strong>返回继续执行原程序</strong>。</li></ul></blockquote><h3 id="什么是中断系统"><a href="#什么是中断系统" class="headerlink" title="什么是中断系统"></a>什么是中断系统</h3><blockquote><ul><li>实现中断功能的软、硬件系统统称为中断系统。</li></ul></blockquote><h3 id="中断的流程"><a href="#中断的流程" class="headerlink" title="中断的流程"></a>中断的流程</h3><p><img src="/posts/19124/ZD.jpg" alt></p><p>即：<br><strong>中断请求</strong>、<strong>中断响应</strong>、<strong>中断处理</strong>、<strong>中断返回</strong></p><h3 id="常见的几个概念"><a href="#常见的几个概念" class="headerlink" title="常见的几个概念"></a>常见的几个概念</h3><blockquote><ul><li><strong>现行程序</strong>：计算机正在执行的程序</li><li><strong>中断源</strong>：提出中断申请的设备</li><li><strong>中断请求</strong>：发出的请求中断的信号</li><li><strong>中断响应</strong>：终止现行程序为申请中断的设备服务</li><li><strong>中断服务程序</strong>：为申请中断的设备服务</li><li><strong>中断返回</strong>：返回继续执行现行程序</li><li><strong>中断点</strong>：中断发生的地址</li></ul></blockquote><h3 id="中断的优先级控制"><a href="#中断的优先级控制" class="headerlink" title="中断的优先级控制"></a>中断的优先级控制</h3><p>通常情况下，一个程序中可能会有多个中断，优先级越高的中断优先执行。如果在一个中断的服务过程中，有一个优先级更高的中断插入，则当前中断暂停，前往执行优先级更高的中断。当优先级高的中断执行完毕后再返回继续执行低优先级的中断。</p><h3 id="中断的响应过程"><a href="#中断的响应过程" class="headerlink" title="中断的响应过程"></a>中断的响应过程</h3><h4 id="单级中断响应过程"><a href="#单级中断响应过程" class="headerlink" title="单级中断响应过程"></a>单级中断响应过程</h4><p><img src="/posts/19124/ZD-2.jpg" alt></p><h4 id="两级嵌套中断响应过程"><a href="#两级嵌套中断响应过程" class="headerlink" title="两级嵌套中断响应过程"></a>两级嵌套中断响应过程</h4><p><img src="/posts/19124/ZD-1.jpg" alt></p><h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><ul><li><strong>MCS-51共有五个中断源</strong></li></ul><blockquote><ul><li>外部中断<code>INT0</code>、<code>INT1</code></li><li>定时/计数器<code>T0</code>和<code>T1</code>的溢出中断</li><li>串行口的发送和接受中断(只占用一个中断源)</li></ul></blockquote><table><thead><tr><th>中断源</th><th>功能</th></tr></thead><tbody><tr><td><code>INT0</code></td><td>外部中断0请求，由<code>INT0</code>引脚(P3.2)输入。低电平/负跳变有效，中断请求标志为IE0</td></tr><tr><td><code>INT1</code></td><td>外部中断1请求，由<code>INT1</code>引脚(P3.3)输入。低电平/负跳变有效，中断请求标志为IE1</td></tr><tr><td><code>T0</code></td><td>定时/计数器0溢出中断请求，中断标志位为<code>TF0</code></td></tr><tr><td><code>T1</code></td><td>定时/计数器1溢出中断请求，中断标志位为<code>TF1</code></td></tr><tr><td><code>RXD/TXD</code></td><td>串行口中断请求，中断请求标志位<code>TI</code>或<code>RI</code></td></tr></tbody></table><h3 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h3><h4 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h4><p>从单片机外部引脚<code>INT0</code>和<code>INT1</code>输入中断请求信号的中断。<br>外部中断的触发方式有两种<strong>电平触发</strong>[<code>IT0 =0</code>]和<strong>跳变触发(边沿)</strong>[<code>IT0 = 1</code>]，可以通过定时/计数器控制寄存器<code>TCON</code>编程选择。</p><h4 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h4><h3 id="中断控制寄存器"><a href="#中断控制寄存器" class="headerlink" title="中断控制寄存器"></a>中断控制寄存器</h3><blockquote><ul><li>MCS-51中断系统在4个特殊功能寄存器控制下工作，分别为定时/计数器控制寄存器(<code>TCON</code>)、串行口控制寄存器(<code>SCON</code>)、中断允许控制寄存器(<code>IE</code>)、中断优先级控制寄存器(<code>IP</code>)。下面一一解释。</li></ul></blockquote><h4 id="中断请求控制"><a href="#中断请求控制" class="headerlink" title="中断请求控制"></a>中断请求控制</h4><h5 id="定时-计数器控制寄存器-TCON"><a href="#定时-计数器控制寄存器-TCON" class="headerlink" title="定时/计数器控制寄存器 TCON"></a>定时/计数器控制寄存器 <code>TCON</code></h5><p><strong>作用</strong></p><blockquote><ul><li><ol><li>控制定时/计数器<code>T0</code>和<code>T1</code>的溢出中断</li></ol></li><li><ol start="2"><li>控制外部中断的触发方式.由<code>IT0</code>和<code>IT1</code>控制</li></ol></li><li><ol start="3"><li>锁存外部中断请求标志位</li></ol></li></ul></blockquote><p><img src="/posts/19124/ZD-3.jpg" alt></p><table><thead><tr><th>位地址</th><th>位定义</th><th>功能</th></tr></thead><tbody><tr><td>88H</td><td>IT0</td><td>选择外部中断0的中断触发方式。由软件控制。<code>IT0=0为电平触发方式</code>。<code>IT0=1为下降沿触发方式</code></td></tr><tr><td>89H</td><td>IE0</td><td>选择外部中断1的中断触发方式。功能与<code>IT0</code>相似</td></tr><tr><td>8AH</td><td></td><td></td></tr></tbody></table><h5 id="串行口控制寄存器-SCON"><a href="#串行口控制寄存器-SCON" class="headerlink" title="串行口控制寄存器 SCON"></a>串行口控制寄存器 <code>SCON</code></h5><p><strong>串行口的接收发送数据中断请求标志位</strong>(<code>RI</code>和<code>TI</code>)</p><table><thead><tr><th>位定义</th><th>功能</th></tr></thead><tbody><tr><td><code>TI</code></td><td>串行口发送中断请求标志位。CPU每发送一帧数据，硬件置位1(<code>TI=1</code>)，但是中断被响应时，需要在中断服务程序中通过软件对<code>TI</code>清零</td></tr><tr><td><code>RI</code></td><td>串行口接受中断请求标志位。每接收一帧数据，硬件置位1(<code>TI=1</code>)，但是中断被响应时，一样需要在中断服务程序中通过软件对<code>TI</code>清零</td></tr></tbody></table><blockquote><ul><li>串行口中断不能由硬件自动清除中断请求标志位，需要用户通过软件进行控制清零。</li></ul></blockquote><h4 id="中断允许控制"><a href="#中断允许控制" class="headerlink" title="中断允许控制"></a>中断允许控制</h4><h5 id="中断允许控制寄存器-IE"><a href="#中断允许控制寄存器-IE" class="headerlink" title="中断允许控制寄存器 IE"></a>中断允许控制寄存器 <code>IE</code></h5><p><code>IE</code>是控制中断的开关，通过对<code>IE</code>的清0和置1操作来控制中断的屏蔽和开放。</p><p>中断允许控制寄存器<code>IE</code>对中断的开放与屏蔽实现两级控制，存在一个总的中断控制位<code>EA</code></p><h6 id="IE各位定义"><a href="#IE各位定义" class="headerlink" title="IE各位定义"></a><code>IE</code>各位定义</h6><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>位地址</td><td>AFH</td><td>AEH</td><td>ADH</td><td>ACH</td><td>ABH</td><td>AAH</td><td>A9H</td><td>A8H</td></tr><tr><td>位定义</td><td>EA</td><td></td><td></td><td>ES</td><td>ET1</td><td>EX1</td><td>ET0</td><td>EX0</td></tr></tbody></table><h6 id="IE各位定义的功能"><a href="#IE各位定义的功能" class="headerlink" title="IE各位定义的功能"></a><code>IE</code>各位定义的功能</h6><table><thead><tr><th>位定义</th><th>功能</th></tr></thead><tbody><tr><td><code>EA</code></td><td>总中断允许控制位。当<code>EA=0</code>时，不允许任何中断请求。</td></tr><tr><td><code>ES</code></td><td>串行口中断控制位。当<code>ES=0</code>时，不允许串行口中断；当<code>EA=1</code>且<code>ES=1</code>时，允许串行口中断。</td></tr><tr><td><code>ET1</code></td><td>定时/计数器1中断允许控制位。当<code>ET1=0</code>时，屏蔽<code>T1</code>的溢出中断；当EA=1且<code>ET1=1</code>时，允许T1溢出中断</td></tr><tr><td><code>ET0</code></td><td>定时/计数器0中断允许控制位。功能与<code>ET1</code>相同。</td></tr><tr><td><code>EX1</code></td><td>外部中断1的中断允许控制位。当<code>EX1=0</code>时，屏蔽外部中断1的中断请求；当<code>EA=1</code>且<code>EX1=1</code>时，允许外部中断1的中断请求</td></tr><tr><td><code>EX0</code></td><td>外部中断0的中断允许控制位。功能与<code>EX1</code>相同</td></tr></tbody></table><blockquote><ul><li>若某个中断源被允许，出来<code>IE</code>对应位置1外，还需要总中断控制位<code>EA</code>置1</li></ul></blockquote><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p>若允许片内两个定时/计数器中断，禁止其他中断源的中断请求，是编写出设置IE的响应指令</p><p><strong>位操作指令</strong></p><pre><code>CLR  EX0  ; 禁止外部中断0CLR  EX1  ; 禁止外部中断1CLR  ES   ; 禁止串行口中断SETB ET0  ; 允许定时/计数器0中断SETB ET1  ; 允许定时/计数器1中断SETB EA   ; 总中断控制器打开</code></pre><p><strong>C语言</strong></p><pre class="line-numbers language-C"><code class="language-C">#include <reg51.h>EX0 = 0; // 禁止外部中断0EX1 = 0; // 禁止外部中断1ES = 0;  // 禁止串行口中断ET0 = 1; // 允许定时/计数器0中断ET1 = 1; // 允许定时/计数器1中断EA = 1;  // 总中断控制器打开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中断优先级控制"><a href="#中断优先级控制" class="headerlink" title="中断优先级控制"></a>中断优先级控制</h4><h5 id="中断优先级控制寄存器-IP"><a href="#中断优先级控制寄存器-IP" class="headerlink" title="中断优先级控制寄存器 IP"></a>中断优先级控制寄存器 <code>IP</code></h5><h6 id="IP各位定义"><a href="#IP各位定义" class="headerlink" title="IP各位定义"></a><code>IP</code>各位定义</h6><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>位地址</td><td></td><td></td><td></td><td>BC</td><td>BB</td><td>BA</td><td>B9</td><td>B8</td></tr><tr><td>位定义</td><td></td><td></td><td></td><td>PS</td><td>PT1</td><td>PX1</td><td>PT0</td><td>PX0</td></tr></tbody></table><h6 id="IP各位定义的功能"><a href="#IP各位定义的功能" class="headerlink" title="IP各位定义的功能"></a><code>IP</code>各位定义的功能</h6><table><thead><tr><th>位定义</th><th>功能</th></tr></thead><tbody><tr><td><code>PS</code></td><td>串行口中断优先级控制位。PS=1，串行口中断为高优先级；PS=0，为低优先级。</td></tr><tr><td><code>PT1</code></td><td>定时/计数器1中断优先级控制位。当<code>PT1=0</code>时，T1溢出中断为低优先级；当<code>PT1=1</code>时，T1溢出中断为高优先级。</td></tr><tr><td><code>PT0</code></td><td>定时/计数器0中断优先级控制位。当<code>PT0=0</code>时，T0溢出中断为低优先级；当<code>PT0=1</code>时，T0溢出中断为高优先级。</td></tr><tr><td><code>PX1</code></td><td>外部中断1的中断优先级控制位。当<code>PX1=0</code>时，外部中断1为低优先级；当<code>PX1=1</code>时，外部中断1为高优先级。</td></tr><tr><td><code>PX0</code></td><td>外部中断0的中断优先级控制位。当<code>PX0=0</code>时，外部中断0为低优先级；当<code>PX0=1</code>时，外部中断0为高优先级。</td></tr></tbody></table><h6 id="同级内第二优先级的次序"><a href="#同级内第二优先级的次序" class="headerlink" title="同级内第二优先级的次序"></a>同级内第二优先级的次序</h6><p><strong>外部中断0</strong> &gt; <strong>T0溢出中断</strong> &gt; <strong>外部中断1</strong> &gt; <strong>T1溢出中断</strong> &gt; <strong>串行口中断</strong></p><h3 id="中断系统在实际编程中的应用"><a href="#中断系统在实际编程中的应用" class="headerlink" title="中断系统在实际编程中的应用"></a>中断系统在实际编程中的应用</h3><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><p><strong>中断的初始化</strong></p><pre class="line-numbers language-C"><code class="language-C">#include <reg51.h>void init() // 中断的初始化函数{    EA = 1; // 总中断控制位    ES = 1; // 串行口中断允许    EX0 = 1; // 外部中断0允许    EX1 = 1; // 外部中断1允许    ET0 = 1; // 定时/计数器0中断允许    ET1 = 1; // 定时/计数器1中断允许    IT0 = 1; // 选择外部中断0的触发方式    IT1 = 1; // 选择外部中断1的触发方式}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果有二种或以上的中断，那就需要在初始化函数中通过IP优先级控制寄存器规定各个中断的优先级</p><p><strong>例1</strong>：假设允许外部中断0和1中断，并设定外部中断0为高级中断，外部中断1为低级中断，外部中断0为下降沿触发方式，外部中断1为电平触发方式。试写出该程序的中断初始化程序。</p><pre class="line-numbers language-C"><code class="language-C">#include <reg51.h>void init() // {    EA = 1; 打开中断控制    EX0 = 1; 允许外部中断0    EX1 = 1; 允许外部中断1    IT0 = 1; 外部中断1采取边沿触发方式    IT1 = 0; 外部中断0采取电平触发方式    PX0 = 1; 外部中断0为高优先级    PX1 = 0; 外部中断1为低优先级}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><p>废话不多说，实战析问题</p><p><strong>例2</strong>：用80C51单片机控制8个LED灯，在外部中断0输入引脚(P3.2)接一个开关K1。要求将外部中断0设置为下降沿触发，程序启动是8个LED以跑马灯的形式交替闪烁。每按一次开关K1，使引脚接地，产生一个下降沿触发的外部中断请求。在中断服务程序中，8个LED高四位和低四位交替闪烁5次，然后中断返回，8个LED继续以跑马灯形式闪烁。</p><blockquote><ul><li><strong>采用<code>Protues</code>+<code>Keil</code>仿真</strong> </li></ul></blockquote><p><strong>元器件</strong></p><blockquote><ul><li>单片机：<code>80C51</code> *1</li><li>开关按钮：<code>Button</code> *1</li><li>电阻：<code>MINRES470K</code> *1</li><li>LED：<code>LED-BLUE</code> *8</li></ul></blockquote><p><strong>仿真图</strong></p><p><img src="/posts/19124/0.png" alt></p><p><strong>代码</strong></p><pre class="line-numbers language-C"><code class="language-C">#include<reg52.h>unsigned char code table[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f,0x00,0xff};    // 控制P2端口的状态unsigned char i,j,k,num;void delay()             // 延时函数{    for(i = 0;i<100;i++)    {        for(j=0;j<200;j++)        ;    }}void init()           // 中断的初始化{    EA = 1;       // 打开总中断控制    EX0 = 1;   // 允许外部中断0    IT0 = 1;   // 外部中断为下降沿触发方式}void main()       {    init();    while(1)    {        for(num =0;num<10;num++)        {            P2 = table[num];            delay();        }    }}void int0() interrupt 0               // 中断服务程序{    for(k = 0;k<5;k++){        P2 = 0xf0;        delay();        P2=0x0f;        delay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h4><p><strong>例3</strong>：在<strong>例2</strong>的基础上，在外部中断1输入引脚(P3.3)接一只按钮开关K2。当按下K1时，外部中断0下降沿触发方式触发，进入外部中断0服务程序，上下4个灯交替闪烁；此时按下K2，外部中断1下降沿触发方式触发，进入外部中断1服务程序，8个灯交替闪烁。当外部中断1响应完毕后，返回继续响应外部中断0，直到外部中断0响应完毕，返回执行主程序。</p><p><strong>首先我们分析一波中断初始化函数</strong></p><blockquote><ul><li>两个外部中断0和1。外部中断0的服务程序为上下4灯交替闪烁，外部中断1的服务程序为8灯闪烁。即<code>EA = 1; EX0 = 1; EX1 = 1;</code></li></ul></blockquote><blockquote><ul><li>优先级：外部中断1 &gt; 外部中断0  即<code>PX1 = 1; PX0 = 0;</code></li></ul></blockquote><blockquote><ul><li>触发方式：都为下降沿触发。即<code>IT0 = 1; IT1 = 1;</code></li></ul></blockquote><p>这样我们的中断初始化程序基本完成</p><pre class="line-numbers language-C"><code class="language-C">void init(){    EA = 1;    EX0 = 1; EX1 = 1;    PX0 = 0; PX1 = 1;    IT0 = 1; IT1 = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其次我们再捯饬一下主程序</strong></p><blockquote><ul><li>我们知道由<strong>例2</strong>知道，程序启动8个LED为流水形式闪烁。</li></ul></blockquote><pre class="line-numbers language-C"><code class="language-C">void main()       {    init();    while(1)    {        for(num =0;num<10;num++)        {            P2 = table[num];            delay();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>另外我们再搞一下外部中断0的服务程序</strong></p><pre class="line-numbers language-C"><code class="language-C">void int0() interrupt 0{    for(k = 0;k<5;k++)    {        P2 = 0xf0;        delay();        P2=0x0f;        delay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>最后我们再敲他喵的弄一下外部中断1的服务程序</strong></p><pre class="line-numbers language-C"><code class="language-C">void int1() interrupt 2              // 外部中断1服务程序{    for(l = 0;l < 5; l++)    {        P2 = 0x00;        delay();        P2 = 0xff;        delay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>大功告成</strong></p><pre class="line-numbers language-C"><code class="language-C">#include<reg52.h>unsigned char code table[] = {0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f, 0x00, 0xff};    // 控制P2端口的状态unsigned char i, j, k, l, num;void delay()             // 延时函数{    for(i = 0; i < 200; i++)    {        for(j = 0; j < 200; j++)        ;    }}void init()           // 中断的初始化{    EA = 1;    EX0 = 1; EX1 = 1;    PX0 = 0; PX1 = 1;    IT0 = 1; IT1 = 1;}void main()       {    init();    while(1)    {        for(num = 0; num < 10; num++)        {            P2 = table[num];            delay();        }    }}void int0() interrupt 0               // 外部中断0中断服务程序{    EX0 = 0;    for(k = 0; k < 5; k++)    {        P2 = 0xf0;        delay();        P2 = 0x0f;        delay();        EX0 = 1;    }}void int1() interrupt 2              // 外部中断1服务程序{    for(l = 0;l < 5; l++)    {        P2 = 0x00;        delay();        P2 = 0xff;        delay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>奉上Protues仿真图</strong></p><p><img src="/posts/19124/2.png" alt></p><h2 id="定时-计数器"><a href="#定时-计数器" class="headerlink" title="定时/计数器"></a>定时/计数器</h2><p><a href="http://zsb1999.com/posts/14549.html" target="_blank" rel="noopener">定时/计数器部分</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验：数码管实现秒表</title>
      <link href="/posts/29895.html"/>
      <url>/posts/29895.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><ul><li>如果你还没有掌握七段数码管的显示原理，请看另一篇文章 。</li></ul></blockquote><blockquote><ul><li>实验依旧采用<code>Protues</code>+<code>Keil</code>仿真。</li></ul></blockquote><h2 id="元器件"><a href="#元器件" class="headerlink" title="元器件"></a>元器件</h2><blockquote><ul><li>单片机：<code>80C51</code></li><li>数码管：<code>7SEG-MPX6-CA</code> <em>共阳极</em></li></ul></blockquote><h2 id="Protues-接线图"><a href="#Protues-接线图" class="headerlink" title="Protues 接线图"></a>Protues 接线图</h2><p><img src="/posts/29895/MB-1.png" alt></p><h3 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h3><ul><li><p><code>P2口</code>：控制数码管的七段发光二极管和DP。</p></li><li><p><code>P3口</code>：控制6个数码管的供电</p></li></ul><h3 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h3><p><strong>特性</strong></p><blockquote><ul><li>六个数码管集成在一起，所有阳极连接在<code>+5V</code>，所以<code>P3</code>口输出低电平时有效。</li></ul></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>第一步</strong></p><ul><li>给每一个数码管分工。</li></ul><blockquote><ul><li>数码管1显示分钟的十位</li><li>数码管2显示分钟的个位</li><li>数码管3显示秒钟的十位</li><li>数码管4显示秒钟的个位</li><li>数码管5显示毫秒的十位</li><li>数码管6显示毫秒的个位</li></ul></blockquote><p><strong>第二步</strong></p><blockquote><ul><li>毫秒的显示范围是<code>0~99ms</code></li><li>秒钟的显示范围是<code>0~59s</code></li><li>分钟的显示范围是<code>0~59min</code></li></ul></blockquote><p><strong><em>这样我们就规定好了6个数码管分别显示的内容和范围。</em></strong><br><strong>第三步</strong></p><p>毫秒的个位就是每<code>1ms</code> 加<code>1</code>，这里就用到<strong>定时/计数器</strong>和<strong>中断</strong></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验:七段数码管的显示</title>
      <link href="/posts/36872.html"/>
      <url>/posts/36872.html</url>
      
        <content type="html"><![CDATA[<h1 id="七段数码管"><a href="#七段数码管" class="headerlink" title="七段数码管"></a>七段数码管</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><ul><li>之前老师讲了用51单片机控制七段数码管的显示，经过几节课的讲解，大概掌握了七段数码管的显示原理，最后老师布置了一个作业，用51单片机控制单片机的显示实现一个秒表。</li><li>下面就以实现秒表的这个实例，总结一下七段数码管显示所涉及到的知识，与大家分享、交流，希望可以帮助到同学们。</li><li><strong>注</strong>：<strong>首先</strong>由于条件有限只能采用Protues+Keil进行仿真，<strong>另外</strong>，能力有限，调试过程可能有一些不足，如果大家有更好的方法，欢迎大家与我分享。</li></ul></blockquote><p> 七段数码管的显示原理</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>七段数码管是由8数码管组成的，其中七个用来显示，另一个为右下角的DP。共有10接线口，八个为a~h段二极管和DP，还有两个为接电源和接地。如果想显示某个字符，只需要将对应的二极管导通，最后组合起来，即可完成显示。</p><h3 id="实物图"><a href="#实物图" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/posts/36872/QDSMG-1.jpg" alt></p><h3 id="接线图"><a href="#接线图" class="headerlink" title="接线图"></a>接线图</h3><p><img src="/posts/36872/QDSMG-2.jpg" alt></p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>七段数码管分两为共阳极、共阴极两种</p><p><strong>如下图</strong></p><p><img src="/posts/36872/QDSMG-3.jpg" alt></p><ul><li>共阳极：二极管的阳极连在一起，对应的a~h为低电平时，二极管导通。</li><li>共阴极：二极管的阴极连在一起，对应的a~h为高电平时，二极管导通。</li></ul><h3 id="实例一：动态显示数字0-9"><a href="#实例一：动态显示数字0-9" class="headerlink" title="实例一：动态显示数字0~9"></a>实例一：动态显示数字0~9</h3><p><strong>显示数字0-9</strong></p><p><strong>Protues仿真图</strong></p><p><strong>元器件</strong></p><blockquote><ul><li>单片机：80C51</li><li>共阳极数码管：7SEG-COM-ANOD</li></ul></blockquote><p><img src="/posts/36872/QDSMG-3.png" alt></p><p>如果我们想显示数字9，共阳极低电平有效。P2口对应8位二进制数00010000</p><pre class="line-numbers language-C"><code class="language-C"># include  <reg52.h>void main(){    P2 = 0x10; // 给P2口传递二进制数00010000，相当于16进制0x10。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果图</strong></p><p><img src="/posts/36872/QDSMG-4.png" alt></p><p>同理，我们可以做一个数组，放入显示0-9所对应的16进制数。</p><p><strong>实现动态循环显示0~9</strong></p><p><strong>效果图</strong></p><blockquote><ul><li>下图这是截取的部分gif。 </li></ul></blockquote><p><img src="/posts/36872/QDSMG-7.gif" alt></p><p><strong>代码</strong></p><pre class="line-numbers language-C"><code class="language-C"># include < reg52.h >table[] = {0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00, 0x10};       // 这是0~9对应的16进制数int n,i,j,k;void display(n)      // 控制显示{    P2 = table[n]; //调用数组中对应的16进制数}void delay()          // 延时函数{    for(i = 0; i < 500; i++)        for(j = 0; j < 200; j++);}void main()              // 主函数{    for(k = 0; k < 10; k++)      // k循环10次    {        display(k);            // 调用显示函数，把k赋值给参数        delay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验:LED点阵的显示</title>
      <link href="/posts/2636.html"/>
      <url>/posts/2636.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验:LCD1602的显示</title>
      <link href="/posts/59324.html"/>
      <url>/posts/59324.html</url>
      
        <content type="html"><![CDATA[<h1 id="LCD液晶显示-以LCD1602为例"><a href="#LCD液晶显示-以LCD1602为例" class="headerlink" title="LCD液晶显示-以LCD1602为例"></a>LCD液晶显示-以<code>LCD1602</code>为例</h1><blockquote><ul><li>LCD1602中的16表示每行显示16个字符，02表示可以显示两行</li></ul></blockquote><h2 id="一、LCD1602实物图"><a href="#一、LCD1602实物图" class="headerlink" title="一、LCD1602实物图"></a>一、LCD1602实物图</h2><p><img src="/posts/59324/LCD1602-1.jpg" alt></p><h2 id="二、LCD1602引脚图"><a href="#二、LCD1602引脚图" class="headerlink" title="二、LCD1602引脚图"></a>二、LCD1602引脚图</h2><p><img src="/posts/59324/LCD1602-2.jpg" alt></p><h3 id="1-引脚功能"><a href="#1-引脚功能" class="headerlink" title="1.引脚功能"></a>1.引脚功能</h3><ul><li>1脚：Vss电源接地</li><li>2脚：VDD电源正(+5V)</li><li>3脚：VL对比度调整 电压越低对比度越高</li><li>4脚：RS寄存器选择 高电平为数据寄存器 低电平为指令寄存器</li><li>5脚：R/W读写信号线即Read/Write，高电平Read低电平Write</li><li>6脚：E势能端，1 -&gt; 0时写操作，1时读操作</li><li>7~14：DB0-DB7是8位双向数据线</li><li>15脚：背光电源+极</li><li>16脚：背光电源-极</li></ul><table><thead><tr><th>引脚号</th><th>符号</th><th>功能</th><th>引脚号</th><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>VSS</td><td>电源接地</td><td>9</td><td>DB2</td><td>数据总线</td></tr><tr><td>2</td><td>VDD</td><td>电源正(+5V)</td><td>10</td><td>DB3</td><td>数据总线</td></tr><tr><td>3</td><td>VL</td><td>对比度调整。电压越低对比度越高</td><td>11</td><td>DB4</td><td>数据总线</td></tr><tr><td>4</td><td>RS</td><td>寄存器选择1为数据寄存器0为指令寄存器</td><td>12</td><td>DB5</td><td>数据总线</td></tr><tr><td>5</td><td>R/W</td><td>读写信号线即Read/Write，1为</td><td>13</td><td>DB6</td><td>数据总线</td></tr><tr><td>6</td><td>E</td><td>使能端。1-&gt;0下降沿有效执行写操作,1读操作</td><td>14</td><td>DB7</td><td>数据总线</td></tr><tr><td>7</td><td>DB0</td><td>数据总线</td><td>15</td><td>E1</td><td>背光电源+</td></tr><tr><td>8</td><td>DB1</td><td>数据总线</td><td>16</td><td>E2</td><td>背光电源-</td></tr></tbody></table><h3 id="2-LCD显示RAM地址"><a href="#2-LCD显示RAM地址" class="headerlink" title="2.LCD显示RAM地址"></a>2.LCD显示RAM地址</h3><p><img src="/posts/59324/LCD1602-3.jpg" alt></p><h3 id="3-指令集"><a href="#3-指令集" class="headerlink" title="3.指令集"></a>3.指令集</h3><p><img src="/posts/59324/LCD1602-4.jpg" alt></p><p> <strong>接下来在具体实验中详细解释</strong></p><h2 id="三、RS与R-W的的作用"><a href="#三、RS与R-W的的作用" class="headerlink" title="三、RS与R/W的的作用"></a>三、RS与R/W的的作用</h2><blockquote><ul><li>当RS=0，R/W=0时。RS选择指令寄存器，R/W写操作，即为写指令。</li><li>当RS=0，R/W=1时。RS选择指令寄存器，R/W读操作，即为读指令。</li><li>当RS=1，R/W=0时。RS选择数据寄存器，R/W写操作，即为写数据。</li><li>当RS=1，R/W=1时。RS选择数据寄存器，R/W读操作，即为读数据。</li></ul></blockquote><h2 id="四、判”忙”函数的使用"><a href="#四、判”忙”函数的使用" class="headerlink" title="四、判”忙”函数的使用"></a>四、判”忙”函数的使用</h2><h2 id="五、LCD1602显示”Hello-World”字符串"><a href="#五、LCD1602显示”Hello-World”字符串" class="headerlink" title="五、LCD1602显示”Hello World”字符串"></a>五、LCD1602显示”Hello World”字符串</h2><p><strong>LCD1602的显示一共分为一下几个步骤</strong></p><ul><li>1.写指令</li><li>2.写数据</li><li>3.初始化</li><li>4.判忙</li></ul><p>我们使用<strong><em>Protues</em></strong>软件做仿真实验</p><p><strong>元器件</strong>：</p><ul><li>80C51单片机</li><li>LCD：LM016L</li><li>8排的组装电阻 RESPACK-8 </li></ul><p><strong>提示</strong>：<em>因为我用P0口做数据总线，P0口没有上拉电阻无法提供高电平，所以要加一个电阻包</em></p><p><strong>Protues仿真图</strong></p><p><img src="/posts/59324/LCD1602-5.png" alt></p><h3 id="1-写指令"><a href="#1-写指令" class="headerlink" title="1.写指令"></a>1.写指令</h3><pre class="line-numbers language-C"><code class="language-C">void write_command(uchar cmd) // 写指令  其中cmd为指令内容{    RS = 0; // 低电平选择指令寄存器    RW = 0; // 低电平为写操作    P3 = cmd; // 将指令的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-写数据"><a href="#2-写数据" class="headerlink" title="2.写数据"></a>2.写数据</h3><pre class="line-numbers language-C"><code class="language-C">void write_data(uchar date)  // 写数据{    RS = 1; // 高电平选择数据寄存器    RW = 0; // 低电平为写操作    P3 = date; // 将数据的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><pre class="line-numbers language-C"><code class="language-C">void init()    // LCD初始化{    RW = 0; // 写操作    E = 0; //    write_command(0x38); // 16*2显示 5*7点阵 8位数据接口    write_command(0x0e); // 只显示字符不显示光标    write_command(0x06); // 每写完一个字符，地址+1    write_command(0x01); // 清屏 数据指针清0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-主函数"><a href="#4-主函数" class="headerlink" title="4.主函数"></a>4.主函数</h3><pre class="line-numbers language-C"><code class="language-C">void main() {    init();    write_command(0x80); //从第一行第一列开始    for(num = 0;num < 7; num++)    {        write_data(table1[num]);        delay(5);    }    write_command(0x80 + 0x40);//从第二行第一列开始    for(num = 0;num < 11; num++)    {        write_data(table2[num]);        delay(5);    }    while(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-效果图"><a href="#5-效果图" class="headerlink" title="5.效果图"></a>5.效果图</h3><p><img src="/posts/59324/LCD1602-6.png" alt></p><h3 id="6-完整程序"><a href="#6-完整程序" class="headerlink" title="6.完整程序"></a>6.完整程序</h3><pre class="line-numbers language-C"><code class="language-C">#include<reg52.h>#define uchar unsigned char#define uint unsigned intsbit RS = P2^1; // 寄存器选择 1为数据寄存器 0为指令寄存器sbit RW = P2^2; // 1为读操作 0为写操作sbit E = P2^3; // 使能端uchar num;uchar code table1[] = "Hello World";uchar code table2[] = "Hello World";void delay(uint time)       // 延时函数{    uint x,y;    for( x = time; x > 0; x--)        for( y = 110; y > 0; y--);}void write_command(uchar cmd) // 写指令  其中cmd为指令内容{    RS = 0; // 低电平选择指令寄存器    RW = 0; // 低电平为写操作    P3 = cmd; // 将指令的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}void write_data(uchar date)  // 写数据{    RS = 1; // 高电平选择数据寄存器    RW = 0; // 低电平为写操作    P3 = date; // 将数据的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}void init()    // LCD初始化{    RW = 0; // 写操作    E = 0; //    write_command(0x38); // 16*2显示 5*7点阵 8位数据接口    write_command(0x0e); // 只显示字符不显示光标    write_command(0x06); // 每写完一个字符，地址+1    write_command(0x01); // 清屏 数据指针清0}void main() {    init();    write_command(0x80);    for(num = 0;num < 11; num++)    {        write_data(table1[num]);        delay(5);    }    write_command(0x80 + 0x40);    for(num = 0;num < 11; num++)    {        write_data(table2[num]);        delay(5);    }    while(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>未完待续…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> LCD液晶显示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现图片转化为base64编码格式</title>
      <link href="/posts/64290.html"/>
      <url>/posts/64290.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python实现图片转码base64"><a href="#Python实现图片转码base64" class="headerlink" title="Python实现图片转码base64"></a>Python实现图片转码base64</h1><blockquote><ul><li>只用到base64库和文件操作</li></ul></blockquote><hr><pre class="line-numbers language-Python"><code class="language-Python">import base64with open("image.jpg","wb") as file:    image_base64 = base64.b64encode(file.read())    print(image_base64)file.close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyhton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown中插入图片</title>
      <link href="/posts/50535.html"/>
      <url>/posts/50535.html</url>
      
        <content type="html"><![CDATA[<h1 id="在Markdown中插入图片的几种方法"><a href="#在Markdown中插入图片的几种方法" class="headerlink" title="在Markdown中插入图片的几种方法"></a>在Markdown中插入图片的几种方法</h1><blockquote><ul><li>大家都知道Markdown编辑器是最受欢迎的编辑器之一，它方便、简洁而不简陋的特点被大家所赞扬。如果非要说一个缺点的话，那就是它不支持直接插入图片吧，废话不多说，上才艺，egm~ egm~ egegm~。</li></ul></blockquote><h3 id="先锋篇：安装Hexo插件hexo-asset-image"><a href="#先锋篇：安装Hexo插件hexo-asset-image" class="headerlink" title="先锋篇：安装Hexo插件hexo-asset-image"></a><strong>先锋篇</strong>：安装Hexo插件<strong>hexo-asset-image</strong></h3><ul><li><code>npm install hexo-asset-image --save</code></li><li>安装成功</li></ul><h3 id="一、本地插入"><a href="#一、本地插入" class="headerlink" title="一、本地插入"></a>一、本地插入</h3><h4 id="1-相对路径"><a href="#1-相对路径" class="headerlink" title="1.相对路径"></a>1.相对路径</h4><ul><li>在需要引用图片的位置写入代码格式：<code>![](filename/picture.png)</code>。这是将一个名为filename的图片文件插入到Markdown文件中，前提是这个文件必须要与你的md文件在同一目录下。</li></ul><h4 id="2-内嵌式"><a href="#2-内嵌式" class="headerlink" title="2.内嵌式"></a>2.内嵌式</h4><ul><li>将图片转为base编码格式的图片，<code>![可不填](data:image/png;base64,YOwGnkP...)</code>。</li></ul><blockquote><ul><li>缺点：文章中间加入一串编码，不美观、影响写作。</li></ul></blockquote><ul><li>这样引用可以把所有编码全部放到文章的最后面。<code>![][image]</code>。这行放到文章末尾<code>[image](data:image/png;base64,YOwGnkP...)</code></li></ul><p>至于怎么把图片转化为base64编码格式可以看我这篇文章<a href="https://zsb1999.github.io/posts/64290.html">Python实现图片转base64编码</a>。</p><p><strong>示例</strong><br><img src="/posts/50535/1.png" alt="1"><br><img src="/posts/50535/ABC.png" alt="ABC"></p><h3 id="二、外链插入"><a href="#二、外链插入" class="headerlink" title="二、外链插入"></a>二、外链插入</h3><blockquote><ul><li>外链插入就是把图片放在网络平台(图床)上，生成专属URL，供其他用户访问，这种方法不用下载插件。</li><li>建议大家使用本地方法，如果某一天你使用的图床服务停止了，你的图片URL也会失效。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要搭建个人博客</title>
      <link href="/posts/61471.html"/>
      <url>/posts/61471.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要搭建博客"><a href="#为什么要搭建博客" class="headerlink" title="为什么要搭建博客"></a>为什么要搭建博客</h2><h3 id="博客网站用来干什么"><a href="#博客网站用来干什么" class="headerlink" title="博客网站用来干什么"></a>博客网站用来干什么</h3><blockquote><ul><li>整理知识，在线笔记本</li><li>记录一些有趣的小项目</li><li>分享学习内容，交流经验</li><li>提高写作和总结能力</li></ul></blockquote><h3 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h3><h4 id="1-浅谈"><a href="#1-浅谈" class="headerlink" title="1.浅谈"></a>1.浅谈</h4><p>很久就已经想写博客了，平时做实验、课程设计时总要在网上搜一些大佬的博文。大一学C语言的时候不知道C能用来干什么，出于好奇心的我，刚开始还跟着老师学习、完成要求。随着课程的深入，知识越来越难理解，特别是学到指针部分，得不到一点学习上的成绩感的我放弃了挣扎，真是应了那句话 “编程，从入门到放弃”，嚯嚯嚯。接下来就不得不说说我目前最喜欢的Python了，这可能是我两年来学的最有自信的一门课程了，当然主要还是比较感兴趣，私下练得多。废话不多说了，搭建博客的初衷就是为了记笔记、整理知识点，另外就是可能会得到一点成就感来安慰自己一下。身为一名普通本科院校的学生，我一直都认为师资力量有限可能是弱势。但是教我们那真是绰绰有余了，不过老师确实也不会讲的太深奥，因为我们也理解不了，这样我们就不得不在课下多花一点时间自学，通常都是以视频的形式学习，那笔记就是重中之重了，我的笔记本一直都是学期结束就被我销毁了，所以一直想搭建一个可以永久记录的博客。当然大家也可以使用网上一些很成熟的博客网站，比如CSDN、博客园、简书等等。</p><h4 id="2-整理与总结"><a href="#2-整理与总结" class="headerlink" title="2.整理与总结"></a>2.整理与总结</h4><p>古人云：温故而知新，可以为师矣。我们在日常学习过程中，新知识不可能一次就牢记于心，重要的是复习，在课堂上可能大家都能听懂，但为什么那些学霸们就能牢记知识点，从而解题时得心应手呢？老铁，差别就在这里，哈哈哈哈。因此呢，我们白天上课，晚上闲余时间就可以整理我们一天学到的知识点，一方面可以整理一下知识点，另一方面，在整理的过程中相当于你又巩固了一遍，还有可能发现新的大陆，两全其美的事，何乐而不为呢。兄弟，行动起来吧！</p><h4 id="3-展示自己的能力"><a href="#3-展示自己的能力" class="headerlink" title="3.展示自己的能力"></a>3.展示自己的能力</h4><p>一个很有技术含量的博客网站，就是一个名片，它可以用最短的时间给别人展现你的技术、你的实力。我相信如果你从现在开始写博客，在以后的面试过程中，这也是你积累的成果，一定是一个加分项。不过，重要的是坚持。胖子不是一口吃来的，一个可以说服面试官的博客也不是一蹴而就的，这需要你锲而不舍的坚持以及时间的沉淀。</p><h3 id="为什么选择Hexo-GitHub搭建"><a href="#为什么选择Hexo-GitHub搭建" class="headerlink" title="为什么选择Hexo+GitHub搭建"></a>为什么选择Hexo+GitHub搭建</h3><h4 id="1-能力有限"><a href="#1-能力有限" class="headerlink" title="1.能力有限"></a>1.能力有限</h4><p>搭建博客之前在网上了解了很多搭建个人博客的方式，各式各样，各有特点，各有优势。之前一个同学分享了他的博客网站，用Django框架搭建的，可以在后台直接写文章，非常的方便。有兴趣的话大家可以去看一下他的博客<a href="https://alididi.club/" target="_blank" rel="noopener">HYuan的博客</a>，因为我能力有限还没接触过Django，所以只能仰慕大佬了，暑假再去追寻大佬的脚步。</p><h4 id="2-简单、免费"><a href="#2-简单、免费" class="headerlink" title="2.简单、免费"></a>2.简单、免费</h4><p>搭建一个我这样的博客真的是有手就行，网上又有很多教程大家可以去参考。</p><h4 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3.缺点"></a>3.缺点</h4><h5 id="1-写文章方面"><a href="#1-写文章方面" class="headerlink" title="1.写文章方面"></a>1.写文章方面</h5><p>就是我前面所说的，它不能在线写文章，因为Hexo是把静态的文件托管到GitHub上的，它要先生成静态的文件，再上传。<br>文章格式是就是.md，也就和markdown编辑器语法格式。可以选择markdown编辑器、Vscode等等。建议大家可以把自己踩的坑记录在手机备忘录里，有时间再一起整理一下，分享到网站上。</p><h5 id="2-部署方面"><a href="#2-部署方面" class="headerlink" title="2.部署方面"></a>2.部署方面</h5><p>因为是静态托管的原因，如果你换了一台新的电脑，就要重新部署文件。建议大家把博客的源文件保存的网盘或者U盘里面。</p><p><strong>今后我会将我之前所有的笔记整理发布到本网站，与大家分享、交流</strong><br><strong>未完待续…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅谈个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
