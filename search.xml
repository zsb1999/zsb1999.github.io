<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MCS-51中断、定时/计数器</title>
      <link href="/posts/19124.html"/>
      <url>/posts/19124.html</url>
      
        <content type="html"><![CDATA[<h2 id="MCS-51中断系统"><a href="#MCS-51中断系统" class="headerlink" title="MCS-51中断系统"></a>MCS-51中断系统</h2><h3 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h3><blockquote><ul><li><strong>中断</strong>就是计算机在执行某一程序的过程中，由计算机系统内部或外部的某种原因而<strong>必须终止当前程序的运行</strong>，先去执行相应的处理程序，然后再返回继续执行原程序。</li></ul></blockquote><h3 id="什么是中断系统"><a href="#什么是中断系统" class="headerlink" title="什么是中断系统"></a>什么是中断系统</h3><blockquote><ul><li>实现中断功能的软、硬件系统统称为中断系统。</li></ul></blockquote><h3 id="中断的流程"><a href="#中断的流程" class="headerlink" title="中断的流程"></a>中断的流程</h3><p><img src="/posts/19124/ZD.jpg" alt></p><p>即：<br><strong>中断请求</strong>、<strong>中断响应</strong>、<strong>中断处理</strong>、<strong>中断返回</strong></p><h3 id="常见的几个概念"><a href="#常见的几个概念" class="headerlink" title="常见的几个概念"></a>常见的几个概念</h3><blockquote><ul><li><strong>现行程序</strong>：计算机正在执行的程序</li><li><strong>中断源</strong>：提出中断申请的设备</li><li><strong>中断请求</strong>：发出的请求中断的信号</li><li><strong>中断响应</strong>：终止现行程序为申请中断的设备服务</li><li><strong>中断服务程序</strong>：为申请中断的设备服务</li><li><strong>中断返回</strong>：返回继续执行现行程序</li><li><strong>中断点</strong>：中断发生的地址</li></ul></blockquote><h3 id="中断的优先级控制"><a href="#中断的优先级控制" class="headerlink" title="中断的优先级控制"></a>中断的优先级控制</h3><p>通常情况下，一个程序中可能会有多个中断，优先级越高的中断优先执行。如果在一个中断的服务过程中，有一个优先级更高的中断插入，则当前中断暂停，前往执行优先级更高的中断。当优先级高的中断执行完毕后再返回继续执行低优先级的中断。</p><h3 id="中断的响应过程"><a href="#中断的响应过程" class="headerlink" title="中断的响应过程"></a>中断的响应过程</h3><h4 id="单级中断响应过程"><a href="#单级中断响应过程" class="headerlink" title="单级中断响应过程"></a>单级中断响应过程</h4><p><img src="/posts/19124/ZD-2.jpg" alt></p><h4 id="两级嵌套中断响应过程"><a href="#两级嵌套中断响应过程" class="headerlink" title="两级嵌套中断响应过程"></a>两级嵌套中断响应过程</h4><p><img src="/posts/19124/ZD-1.jpg" alt></p><h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><ul><li><strong>MCS-51共有五个中断源</strong></li></ul><blockquote><ul><li>外部中断<code>INT0</code>、<code>INT1</code></li><li>定时/计数器<code>T0</code>和<code>T1</code>的溢出中断</li><li>串行口的发送和接受中断(只占用一个中断源)</li></ul></blockquote><table><thead><tr><th>中断源</th><th>功能</th></tr></thead><tbody><tr><td><code>INT0</code></td><td>外部中断0请求，由<code>INT0</code>引脚(P3.2)输入。低电平/负跳变有效，中断请求标志为IE0</td></tr><tr><td><code>INT1</code></td><td>外部中断1请求，由<code>INT1</code>引脚(P3.3)输入。低电平/负跳变有效，中断请求标志为IE1</td></tr><tr><td><code>T0</code></td><td>定时/计数器0溢出中断请求，中断标志位为<code>TF0</code></td></tr><tr><td><code>T1</code></td><td>定时/计数器1溢出中断请求，中断标志位为<code>TF1</code></td></tr><tr><td><code>RXD/TXD</code></td><td>串行口中断请求，中断请求标志位<code>TI</code>或<code>RI</code></td></tr></tbody></table><h3 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h3><h4 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h4><p>从单片机外部引脚<code>INT0</code>和<code>INT1</code>输入中断请求信号的中断。<br>外部中断的触发方式有两种<strong>电平触发</strong>[<code>IT0 =0</code>]和<strong>跳变触发(边沿)</strong>[<code>IT0 = 1</code>]，可以通过定时/计数器控制寄存器<code>TCON</code>编程选择。</p><h4 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h4><h3 id="中断控制寄存器"><a href="#中断控制寄存器" class="headerlink" title="中断控制寄存器"></a>中断控制寄存器</h3><blockquote><ul><li>MCS-51中断系统在4个特殊功能寄存器控制下工作，分别为定时/计数器控制寄存器(<code>TCON</code>)、串行口控制寄存器(<code>SCON</code>)、中断允许控制寄存器(<code>IE</code>)、中断优先级控制寄存器(<code>IP</code>)。下面一一解释。</li></ul></blockquote><h4 id="中断请求控制"><a href="#中断请求控制" class="headerlink" title="中断请求控制"></a>中断请求控制</h4><h5 id="定时-计数器控制寄存器-TCON"><a href="#定时-计数器控制寄存器-TCON" class="headerlink" title="定时/计数器控制寄存器 TCON"></a>定时/计数器控制寄存器 <code>TCON</code></h5><h5 id="串行口控制寄存器-SCON"><a href="#串行口控制寄存器-SCON" class="headerlink" title="串行口控制寄存器 SCON"></a>串行口控制寄存器 <code>SCON</code></h5><h4 id="中断允许控制"><a href="#中断允许控制" class="headerlink" title="中断允许控制"></a>中断允许控制</h4><h5 id="中断允许控制寄存器-IE"><a href="#中断允许控制寄存器-IE" class="headerlink" title="中断允许控制寄存器 IE"></a>中断允许控制寄存器 <code>IE</code></h5><h4 id="中断优先级控制"><a href="#中断优先级控制" class="headerlink" title="中断优先级控制"></a>中断优先级控制</h4><h5 id="中断优先级控制寄存器-IP"><a href="#中断优先级控制寄存器-IP" class="headerlink" title="中断优先级控制寄存器 IP"></a>中断优先级控制寄存器 <code>IP</code></h5><h3 id="中断系统在实际编程中的应用"><a href="#中断系统在实际编程中的应用" class="headerlink" title="中断系统在实际编程中的应用"></a>中断系统在实际编程中的应用</h3><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><h4 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h4><h2 id="定时-计数器"><a href="#定时-计数器" class="headerlink" title="定时/计数器"></a>定时/计数器</h2>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验：数码管实现秒表</title>
      <link href="/posts/29895.html"/>
      <url>/posts/29895.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><ul><li>如果你还没有掌握七段数码管的显示原理，请看另一篇文章 。</li></ul></blockquote><blockquote><ul><li>实验依旧采用<code>Protues</code>+<code>Keil</code>仿真。</li></ul></blockquote><h2 id="元器件"><a href="#元器件" class="headerlink" title="元器件"></a>元器件</h2><blockquote><ul><li>单片机：<code>80C51</code></li><li>数码管：<code>7SEG-MPX6-CA</code> <em>共阳极</em></li></ul></blockquote><h2 id="Protues-接线图"><a href="#Protues-接线图" class="headerlink" title="Protues 接线图"></a>Protues 接线图</h2><p><img src="/posts/29895/MB-1.png" alt></p><h3 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h3><ul><li><p><code>P2口</code>：控制数码管的七段发光二极管和DP。</p></li><li><p><code>P3口</code>：控制6个数码管的供电</p></li></ul><h3 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h3><p><strong>特性</strong></p><blockquote><ul><li>六个数码管集成在一起，所有阳极连接在<code>+5V</code>，所以<code>P3</code>口输出低电平时有效。</li></ul></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>第一步</strong></p><ul><li>给每一个数码管分工。</li></ul><blockquote><ul><li>数码管1显示分钟的十位</li><li>数码管2显示分钟的个位</li><li>数码管3显示秒钟的十位</li><li>数码管4显示秒钟的个位</li><li>数码管5显示毫秒的十位</li><li>数码管6显示毫秒的个位</li></ul></blockquote><p><strong>第二步</strong></p><blockquote><ul><li>毫秒的显示范围是<code>0~99ms</code></li><li>秒钟的显示范围是<code>0~59s</code></li><li>分钟的显示范围是<code>0~59min</code></li></ul></blockquote><p><strong><em>这样我们就规定好了6个数码管分别显示的内容和范围。</em></strong><br><strong>第三步</strong></p><p>毫秒的个位就是每<code>1ms</code> 加<code>1</code>，这里就用到<strong>定时/计数器</strong>和<strong>中断</strong></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验:七段数码管的显示</title>
      <link href="/posts/36872.html"/>
      <url>/posts/36872.html</url>
      
        <content type="html"><![CDATA[<h1 id="七段数码管"><a href="#七段数码管" class="headerlink" title="七段数码管"></a>七段数码管</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><ul><li>之前老师讲了用51单片机控制七段数码管的显示，经过几节课的讲解，大概掌握了七段数码管的显示原理，最后老师布置了一个作业，用51单片机控制单片机的显示实现一个秒表。</li><li>下面就以实现秒表的这个实例，总结一下七段数码管显示所涉及到的知识，与大家分享、交流，希望可以帮助到同学们。</li><li><strong>注</strong>：<strong>首先</strong>由于条件有限只能采用Protues+Keil进行仿真，<strong>另外</strong>，能力有限，调试过程可能有一些不足，如果大家有更好的方法，欢迎大家与我分享。</li></ul></blockquote><p> 七段数码管的显示原理</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>七段数码管是由8数码管组成的，其中七个用来显示，另一个为右下角的DP。共有10接线口，八个为a~h段二极管和DP，还有两个为接电源和接地。如果想显示某个字符，只需要将对应的二极管导通，最后组合起来，即可完成显示。</p><h3 id="实物图"><a href="#实物图" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/posts/36872/QDSMG-1.jpg" alt></p><h3 id="接线图"><a href="#接线图" class="headerlink" title="接线图"></a>接线图</h3><p><img src="/posts/36872/QDSMG-2.jpg" alt></p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>七段数码管分两为共阳极、共阴极两种</p><p><strong>如下图</strong></p><p><img src="/posts/36872/QDSMG-3.jpg" alt></p><ul><li>共阳极：二极管的阳极连在一起，对应的a~h为低电平时，二极管导通。</li><li>共阴极：二极管的阴极连在一起，对应的a~h为高电平时，二极管导通。</li></ul><h3 id="实例一：动态显示数字0-9"><a href="#实例一：动态显示数字0-9" class="headerlink" title="实例一：动态显示数字0~9"></a>实例一：动态显示数字0~9</h3><p><strong>显示数字0-9</strong></p><p><strong>Protues仿真图</strong></p><p><strong>元器件</strong></p><blockquote><ul><li>单片机：80C51</li><li>共阳极数码管：7SEG-COM-ANOD</li></ul></blockquote><p><img src="/posts/36872/QDSMG-3.png" alt></p><p>如果我们想显示数字9，共阳极低电平有效。P2口对应8位二进制数00010000</p><pre class="line-numbers language-C"><code class="language-C"># include  <reg52.h>void main(){    P2 = 0x10; // 给P2口传递二进制数00010000，相当于16进制0x10。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果图</strong></p><p><img src="/posts/36872/QDSMG-4.png" alt></p><p>同理，我们可以做一个数组，放入显示0-9所对应的16进制数。</p><p><strong>实现动态循环显示0~9</strong></p><p><strong>效果图</strong></p><blockquote><ul><li>下图这是截取的部分gif。 </li></ul></blockquote><p><img src="/posts/36872/QDSMG-7.gif" alt></p><p><strong>代码</strong></p><pre class="line-numbers language-C"><code class="language-C"># include < reg52.h >table[] = {0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00, 0x10};       // 这是0~9对应的16进制数int n,i,j,k;void display(n)      // 控制显示{    P2 = table[n]; //调用数组中对应的16进制数}void delay()          // 延时函数{    for(i = 0; i < 500; i++)        for(j = 0; j < 200; j++);}void main()              // 主函数{    for(k = 0; k < 10; k++)      // k循环10次    {        display(k);            // 调用显示函数，把k赋值给参数        delay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验:LED点阵的显示</title>
      <link href="/posts/2636.html"/>
      <url>/posts/2636.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机实验:LCD1602的显示</title>
      <link href="/posts/59324.html"/>
      <url>/posts/59324.html</url>
      
        <content type="html"><![CDATA[<h1 id="LCD液晶显示-以LCD1602为例"><a href="#LCD液晶显示-以LCD1602为例" class="headerlink" title="LCD液晶显示-以LCD1602为例"></a>LCD液晶显示-以<code>LCD1602</code>为例</h1><blockquote><ul><li>LCD1602中的16表示每行显示16个字符，02表示可以显示两行</li></ul></blockquote><h2 id="一、LCD1602实物图"><a href="#一、LCD1602实物图" class="headerlink" title="一、LCD1602实物图"></a>一、LCD1602实物图</h2><p><img src="/posts/59324/LCD1602-1.jpg" alt></p><h2 id="二、LCD1602引脚图"><a href="#二、LCD1602引脚图" class="headerlink" title="二、LCD1602引脚图"></a>二、LCD1602引脚图</h2><p><img src="/posts/59324/LCD1602-2.jpg" alt></p><h3 id="1-引脚功能"><a href="#1-引脚功能" class="headerlink" title="1.引脚功能"></a>1.引脚功能</h3><ul><li>1脚：Vss电源接地</li><li>2脚：VDD电源正(+5V)</li><li>3脚：VL对比度调整 电压越低对比度越高</li><li>4脚：RS寄存器选择 高电平为数据寄存器 低电平为指令寄存器</li><li>5脚：R/W读写信号线即Read/Write，高电平Read低电平Write</li><li>6脚：E势能端，1 -&gt; 0时写操作，1时读操作</li><li>7~14：DB0-DB7是8位双向数据线</li><li>15脚：背光电源+极</li><li>16脚：背光电源-极</li></ul><table><thead><tr><th>引脚号</th><th>符号</th><th>功能</th><th>引脚号</th><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>VSS</td><td>电源接地</td><td>9</td><td>DB2</td><td>数据总线</td></tr><tr><td>2</td><td>VDD</td><td>电源正(+5V)</td><td>10</td><td>DB3</td><td>数据总线</td></tr><tr><td>3</td><td>VL</td><td>对比度调整。电压越低对比度越高</td><td>11</td><td>DB4</td><td>数据总线</td></tr><tr><td>4</td><td>RS</td><td>寄存器选择1为数据寄存器0为指令寄存器</td><td>12</td><td>DB5</td><td>数据总线</td></tr><tr><td>5</td><td>R/W</td><td>读写信号线即Read/Write，1为</td><td>13</td><td>DB6</td><td>数据总线</td></tr><tr><td>6</td><td>E</td><td>使能端。1-&gt;0下降沿有效执行写操作,1读操作</td><td>14</td><td>DB7</td><td>数据总线</td></tr><tr><td>7</td><td>DB0</td><td>数据总线</td><td>15</td><td>E1</td><td>背光电源+</td></tr><tr><td>8</td><td>DB1</td><td>数据总线</td><td>16</td><td>E2</td><td>背光电源-</td></tr></tbody></table><h3 id="2-LCD显示RAM地址"><a href="#2-LCD显示RAM地址" class="headerlink" title="2.LCD显示RAM地址"></a>2.LCD显示RAM地址</h3><p><img src="/posts/59324/LCD1602-3.jpg" alt></p><h3 id="3-指令集"><a href="#3-指令集" class="headerlink" title="3.指令集"></a>3.指令集</h3><p><img src="/posts/59324/LCD1602-4.jpg" alt></p><p> <strong>接下来在具体实验中详细解释</strong></p><h2 id="三、RS与R-W的的作用"><a href="#三、RS与R-W的的作用" class="headerlink" title="三、RS与R/W的的作用"></a>三、RS与R/W的的作用</h2><blockquote><ul><li>当RS=0，R/W=0时。RS选择指令寄存器，R/W写操作，即为写指令。</li><li>当RS=0，R/W=1时。RS选择指令寄存器，R/W读操作，即为读指令。</li><li>当RS=1，R/W=0时。RS选择数据寄存器，R/W写操作，即为写数据。</li><li>当RS=1，R/W=1时。RS选择数据寄存器，R/W读操作，即为读数据。</li></ul></blockquote><h2 id="四、判”忙”函数的使用"><a href="#四、判”忙”函数的使用" class="headerlink" title="四、判”忙”函数的使用"></a>四、判”忙”函数的使用</h2><h2 id="五、LCD1602显示”Hello-World”字符串"><a href="#五、LCD1602显示”Hello-World”字符串" class="headerlink" title="五、LCD1602显示”Hello World”字符串"></a>五、LCD1602显示”Hello World”字符串</h2><p><strong>LCD1602的显示一共分为一下几个步骤</strong></p><ul><li>1.写指令</li><li>2.写数据</li><li>3.初始化</li><li>4.判忙</li></ul><p>我们使用<strong><em>Protues</em></strong>软件做仿真实验</p><p><strong>元器件</strong>：</p><ul><li>80C51单片机</li><li>LCD：LM016L</li><li>8排的组装电阻 RESPACK-8 </li></ul><p><strong>提示</strong>：<em>因为我用P0口做数据总线，P0口没有上拉电阻无法提供高电平，所以要加一个电阻包</em></p><p><strong>Protues仿真图</strong></p><p><img src="/posts/59324/LCD1602-5.png" alt></p><h3 id="1-写指令"><a href="#1-写指令" class="headerlink" title="1.写指令"></a>1.写指令</h3><pre class="line-numbers language-C"><code class="language-C">void write_command(uchar cmd) // 写指令  其中cmd为指令内容{    RS = 0; // 低电平选择指令寄存器    RW = 0; // 低电平为写操作    P3 = cmd; // 将指令的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-写数据"><a href="#2-写数据" class="headerlink" title="2.写数据"></a>2.写数据</h3><pre class="line-numbers language-C"><code class="language-C">void write_data(uchar date)  // 写数据{    RS = 1; // 高电平选择数据寄存器    RW = 0; // 低电平为写操作    P3 = date; // 将数据的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><pre class="line-numbers language-C"><code class="language-C">void init()    // LCD初始化{    RW = 0; // 写操作    E = 0; //    write_command(0x38); // 16*2显示 5*7点阵 8位数据接口    write_command(0x0e); // 只显示字符不显示光标    write_command(0x06); // 每写完一个字符，地址+1    write_command(0x01); // 清屏 数据指针清0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-主函数"><a href="#4-主函数" class="headerlink" title="4.主函数"></a>4.主函数</h3><pre class="line-numbers language-C"><code class="language-C">void main() {    init();    write_command(0x80); //从第一行第一列开始    for(num = 0;num < 7; num++)    {        write_data(table1[num]);        delay(5);    }    write_command(0x80 + 0x40);//从第二行第一列开始    for(num = 0;num < 11; num++)    {        write_data(table2[num]);        delay(5);    }    while(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-效果图"><a href="#5-效果图" class="headerlink" title="5.效果图"></a>5.效果图</h3><p><img src="/posts/59324/LCD1602-6.png" alt></p><h3 id="6-完整程序"><a href="#6-完整程序" class="headerlink" title="6.完整程序"></a>6.完整程序</h3><pre class="line-numbers language-C"><code class="language-C">#include<reg52.h>#define uchar unsigned char#define uint unsigned intsbit RS = P2^1; // 寄存器选择 1为数据寄存器 0为指令寄存器sbit RW = P2^2; // 1为读操作 0为写操作sbit E = P2^3; // 使能端uchar num;uchar code table1[] = "Hello World";uchar code table2[] = "Hello World";void delay(uint time)       // 延时函数{    uint x,y;    for( x = time; x > 0; x--)        for( y = 110; y > 0; y--);}void write_command(uchar cmd) // 写指令  其中cmd为指令内容{    RS = 0; // 低电平选择指令寄存器    RW = 0; // 低电平为写操作    P3 = cmd; // 将指令的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}void write_data(uchar date)  // 写数据{    RS = 1; // 高电平选择数据寄存器    RW = 0; // 低电平为写操作    P3 = date; // 将数据的二进制形式传递给P3口    delay(5);    E = 1;  // 将使能端拉高    delay(5);    E = 0;     // 从高到低 下降沿 写操作}void init()    // LCD初始化{    RW = 0; // 写操作    E = 0; //    write_command(0x38); // 16*2显示 5*7点阵 8位数据接口    write_command(0x0e); // 只显示字符不显示光标    write_command(0x06); // 每写完一个字符，地址+1    write_command(0x01); // 清屏 数据指针清0}void main() {    init();    write_command(0x80);    for(num = 0;num < 11; num++)    {        write_data(table1[num]);        delay(5);    }    write_command(0x80 + 0x40);    for(num = 0;num < 11; num++)    {        write_data(table2[num]);        delay(5);    }    while(1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>未完待续…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> LCD液晶显示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现图片转化为base64编码格式</title>
      <link href="/posts/64290.html"/>
      <url>/posts/64290.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python实现图片转码base64"><a href="#Python实现图片转码base64" class="headerlink" title="Python实现图片转码base64"></a>Python实现图片转码base64</h1><blockquote><ul><li>只用到base64库和文件操作</li></ul></blockquote><hr><pre class="line-numbers language-Python"><code class="language-Python">import base64with open("image.jpg","wb") as file:    image_base64 = base64.b64encode(file.read())    print(image_base64)file.close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyhton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown中插入图片</title>
      <link href="/posts/50535.html"/>
      <url>/posts/50535.html</url>
      
        <content type="html"><![CDATA[<h1 id="在Markdown中插入图片的几种方法"><a href="#在Markdown中插入图片的几种方法" class="headerlink" title="在Markdown中插入图片的几种方法"></a>在Markdown中插入图片的几种方法</h1><blockquote><ul><li>大家都知道Markdown编辑器是最受欢迎的编辑器之一，它方便、简洁而不简陋的特点被大家所赞扬。如果非要说一个缺点的话，那就是它不支持直接插入图片吧，废话不多说，上才艺，egm~ egm~ egegm~。</li></ul></blockquote><h3 id="先锋篇：安装Hexo插件hexo-asset-image"><a href="#先锋篇：安装Hexo插件hexo-asset-image" class="headerlink" title="先锋篇：安装Hexo插件hexo-asset-image"></a><strong>先锋篇</strong>：安装Hexo插件<strong>hexo-asset-image</strong></h3><ul><li><code>npm install hexo-asset-image --save</code></li><li>安装成功</li></ul><h3 id="一、本地插入"><a href="#一、本地插入" class="headerlink" title="一、本地插入"></a>一、本地插入</h3><h4 id="1-相对路径"><a href="#1-相对路径" class="headerlink" title="1.相对路径"></a>1.相对路径</h4><ul><li>在需要引用图片的位置写入代码格式：<code>![](filename/picture.png)</code>。这是将一个名为filename的图片文件插入到Markdown文件中，前提是这个文件必须要与你的md文件在同一目录下。</li></ul><h4 id="2-内嵌式"><a href="#2-内嵌式" class="headerlink" title="2.内嵌式"></a>2.内嵌式</h4><ul><li>将图片转为base编码格式的图片，<code>![可不填](data:image/png;base64,YOwGnkP...)</code>。</li></ul><blockquote><ul><li>缺点：文章中间加入一串编码，不美观、影响写作。</li></ul></blockquote><ul><li>这样引用可以把所有编码全部放到文章的最后面。<code>![][image]</code>。这行放到文章末尾<code>[image](data:image/png;base64,YOwGnkP...)</code></li></ul><p>至于怎么把图片转化为base64编码格式可以看我这篇文章<a href="https://zsb1999.github.io/posts/64290.html">Python实现图片转base64编码</a>。</p><p><strong>示例</strong><br><img src="/posts/50535/1.png" alt="1"><br><img src="/posts/50535/ABC.png" alt="ABC"></p><h3 id="二、外链插入"><a href="#二、外链插入" class="headerlink" title="二、外链插入"></a>二、外链插入</h3><blockquote><ul><li>外链插入就是把图片放在网络平台(图床)上，生成专属URL，供其他用户访问，这种方法不用下载插件。</li><li>建议大家使用本地方法，如果某一天你使用的图床服务停止了，你的图片URL也会失效。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要搭建个人博客</title>
      <link href="/posts/61471.html"/>
      <url>/posts/61471.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要搭建博客"><a href="#为什么要搭建博客" class="headerlink" title="为什么要搭建博客"></a>为什么要搭建博客</h2><h3 id="博客网站用来干什么"><a href="#博客网站用来干什么" class="headerlink" title="博客网站用来干什么"></a>博客网站用来干什么</h3><blockquote><ul><li>整理知识，在线笔记本</li><li>记录一些有趣的小项目</li><li>分享学习内容，交流经验</li><li>提高写作和总结能力</li></ul></blockquote><h3 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h3><h4 id="1-浅谈"><a href="#1-浅谈" class="headerlink" title="1.浅谈"></a>1.浅谈</h4><p>很久就已经想写博客了，平时做实验、课程设计时总要在网上搜一些大佬的博文。大一学C语言的时候不知道C能用来干什么，出于好奇心的我，刚开始还跟着老师学习、完成要求。随着课程的深入，知识越来越难理解，特别是学到指针部分，得不到一点学习上的成绩感的我放弃了挣扎，真是应了那句话 “编程，从入门到放弃”，嚯嚯嚯。接下来就不得不说说我目前最喜欢的Python了，这可能是我两年来学的最有自信的一门课程了，当然主要还是比较感兴趣，私下练得多。废话不多说了，搭建博客的初衷就是为了记笔记、整理知识点，另外就是可能会得到一点成就感来安慰自己一下。身为一名普通本科院校的学生，我一直都认为师资力量有限可能是弱势。但是教我们那真是绰绰有余了，不过老师确实也不会讲的太深奥，因为我们也理解不了，这样我们就不得不在课下多花一点时间自学，通常都是以视频的形式学习，那笔记就是重中之重了，我的笔记本一直都是学期结束就被我销毁了，所以一直想搭建一个可以永久记录的博客。当然大家也可以使用网上一些很成熟的博客网站，比如CSDN、博客园、简书等等。</p><h4 id="2-整理与总结"><a href="#2-整理与总结" class="headerlink" title="2.整理与总结"></a>2.整理与总结</h4><p>古人云：温故而知新，可以为师矣。我们在日常学习过程中，新知识不可能一次就牢记于心，重要的是复习，在课堂上可能大家都能听懂，但为什么那些学霸们就能牢记知识点，从而解题时得心应手呢？老铁，差别就在这里，哈哈哈哈。因此呢，我们白天上课，晚上闲余时间就可以整理我们一天学到的知识点，一方面可以整理一下知识点，另一方面，在整理的过程中相当于你又巩固了一遍，还有可能发现新的大陆，两全其美的事，何乐而不为呢。兄弟，行动起来吧！</p><h4 id="3-展示自己的能力"><a href="#3-展示自己的能力" class="headerlink" title="3.展示自己的能力"></a>3.展示自己的能力</h4><p>一个很有技术含量的博客网站，就是一个名片，它可以用最短的时间给别人展现你的技术、你的实力。我相信如果你从现在开始写博客，在以后的面试过程中，这也是你积累的成果，一定是一个加分项。不过，重要的是坚持。胖子不是一口吃来的，一个可以说服面试官的博客也不是一蹴而就的，这需要你锲而不舍的坚持以及时间的沉淀。</p><h3 id="为什么选择Hexo-GitHub搭建"><a href="#为什么选择Hexo-GitHub搭建" class="headerlink" title="为什么选择Hexo+GitHub搭建"></a>为什么选择Hexo+GitHub搭建</h3><h4 id="1-能力有限"><a href="#1-能力有限" class="headerlink" title="1.能力有限"></a>1.能力有限</h4><p>搭建博客之前在网上了解了很多搭建个人博客的方式，各式各样，各有特点，各有优势。之前一个同学分享了他的博客网站，用Django框架搭建的，可以在后台直接写文章，非常的方便。有兴趣的话大家可以去看一下他的博客<a href="https://alididi.club/" target="_blank" rel="noopener">HYuan的博客</a>，因为我能力有限还没接触过Django，所以只能仰慕大佬了，暑假再去追寻大佬的脚步。</p><h4 id="2-简单、免费"><a href="#2-简单、免费" class="headerlink" title="2.简单、免费"></a>2.简单、免费</h4><p>搭建一个我这样的博客真的是有手就行，网上又有很多教程大家可以去参考。</p><h4 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3.缺点"></a>3.缺点</h4><h5 id="1-写文章方面"><a href="#1-写文章方面" class="headerlink" title="1.写文章方面"></a>1.写文章方面</h5><p>就是我前面所说的，它不能在线写文章，因为Hexo是把静态的文件托管到GitHub上的，它要先生成静态的文件，再上传。<br>文章格式是就是.md，也就和markdown编辑器语法格式。可以选择markdown编辑器、Vscode等等。建议大家可以把自己踩的坑记录在手机备忘录里，有时间再一起整理一下，分享到网站上。</p><h5 id="2-部署方面"><a href="#2-部署方面" class="headerlink" title="2.部署方面"></a>2.部署方面</h5><p>因为是静态托管的原因，如果你换了一台新的电脑，就要重新部署文件。建议大家把博客的源文件保存的网盘或者U盘里面。</p><p><strong>今后我会将我之前所有的笔记整理发布到本网站，与大家分享、交流</strong><br><strong>未完待续…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅谈个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
